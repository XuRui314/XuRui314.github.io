<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>搜索与图论 | XuRui-Blog</title><meta name="keywords" content="算法,算法题目"><meta name="author" content="zxr"><meta name="copyright" content="zxr"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="图论  模板  图的存储 1234567891011/*邻接表存储图*///N是点数， M是边数int h[N], e[M], ne[M], idx, w[M]; //这里w是边的权值//添加一条边a -> bvoid add(int a, int b)&amp;#123;    e[idx] = b, ne[idx] = h[a], h[a] = idx++;&amp;#125;//初始化memset(">
<meta property="og:type" content="article">
<meta property="og:title" content="搜索与图论">
<meta property="og:url" content="https://xurui314.github.io/2021/11/27/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/index.html">
<meta property="og:site_name" content="XuRui-Blog">
<meta property="og:description" content="图论  模板  图的存储 1234567891011/*邻接表存储图*///N是点数， M是边数int h[N], e[M], ne[M], idx, w[M]; //这里w是边的权值//添加一条边a -> bvoid add(int a, int b)&amp;#123;    e[idx] = b, ne[idx] = h[a], h[a] = idx++;&amp;#125;//初始化memset(">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://i.loli.net/2021/10/19/qF6yCf8W2B5GeNx.jpg">
<meta property="article:published_time" content="2021-11-27T01:36:21.000Z">
<meta property="article:modified_time" content="2021-12-03T13:51:26.047Z">
<meta property="article:author" content="zxr">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="算法题目">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/10/19/qF6yCf8W2B5GeNx.jpg"><link rel="shortcut icon" href="https://i.loli.net/2021/07/27/lSHRJbx7dYwTk8f.jpg"><link rel="canonical" href="https://xurui314.github.io/2021/11/27/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '搜索与图论',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-12-03 21:51:26'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    document.addEventListener('pjax:complete', detectApple)})(window)</script><link rel="stylesheet" href="/css/badge.css"><link rel="stylesheet" href="/css/modify.css"><link rel="stylesheet" href="/css/mouse.css"><link rel="stylesheet" href="/dist/APlayer.min.css"><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/bilibiliBanner.css" media="defer" onload="this.media='screen'"><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper/swiper/swiper.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper/swiper/swiperstyle.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/hexo-electric-clock@1.0.6/clock.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css">
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://unpkg.zhimg.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://unpkg.zhimg.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script async="" src="https://unpkg.zhimg.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s2.loli.net/2021/12/08/yTYthVwXD4IPbJ9.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">41</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">21</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">10</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页🍭</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 档案🌊</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签📑</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类🌈</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 好康的✨</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://ocw.mit.edu/"><i class="fa-fw fas fa-link"></i><span> 来学麻学</span></a></li><li><a class="site-page child" href="/bangumis/"><i class="fa-fw fas fa-video"></i><span> zxrの追番计划</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=RyOyXsKuUgI"><i class="fa-fw fas fa-heart"></i><span> zxr最爱滴up嘉倩</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://oskarstalberg.com/game/planet/planet.html"><span> Planet</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链💕</span></a></div><div class="menus_item"><a class="site-page" href="https://xurui314.github.io/aboutme/"><span> AboutMe🏂</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://www.foreverblog.cn/go.html"><span> 虫洞</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2021/10/19/qF6yCf8W2B5GeNx.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">XuRui-Blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页🍭</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 档案🌊</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签📑</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类🌈</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 好康的✨</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://ocw.mit.edu/"><i class="fa-fw fas fa-link"></i><span> 来学麻学</span></a></li><li><a class="site-page child" href="/bangumis/"><i class="fa-fw fas fa-video"></i><span> zxrの追番计划</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=RyOyXsKuUgI"><i class="fa-fw fas fa-heart"></i><span> zxr最爱滴up嘉倩</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://oskarstalberg.com/game/planet/planet.html"><span> Planet</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链💕</span></a></div><div class="menus_item"><a class="site-page" href="https://xurui314.github.io/aboutme/"><span> AboutMe🏂</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://www.foreverblog.cn/go.html"><span> 虫洞</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">搜索与图论</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-11-27T01:36:21.000Z" title="Created 2021-11-27 09:36:21">2021-11-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-12-03T13:51:26.047Z" title="Updated 2021-12-03 21:51:26">2021-12-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/">算法学习</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">8.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>39min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="搜索与图论"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><div class="top-img" style="background-image: url('https://i.loli.net/2021/10/19/qF6yCf8W2B5GeNx.jpg');"></div><article class="post-content" id="article-container"><h1 id="图论"><a class="markdownIt-Anchor" href="#图论"></a> 图论</h1>
<h2 id="模板"><a class="markdownIt-Anchor" href="#模板"></a> 模板</h2>
<h4 id="图的存储"><a class="markdownIt-Anchor" href="#图的存储"></a> 图的存储</h4>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*邻接表存储图*/</span><br><span class="hljs-comment">//N是点数， M是边数</span><br><span class="hljs-keyword">int</span> h[N], e[M], ne[M], idx, w[M]; <span class="hljs-comment">//这里w是边的权值</span><br><br><span class="hljs-comment">//添加一条边a -&gt; b</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>{<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx++;<br>}<br><span class="hljs-comment">//初始化</span><br><span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>idx = <span class="hljs-number">0</span>;<br></code></pre></td></tr></tbody></table></figure>
<blockquote>
<p>理解：这个<code>idx</code>是表示存边信息的数组的下标，所有读入的边都可以对应一个<code>idx</code>，根据出入节点的顺序，可以对应的加到出节点的链上，因为是用数组实现的，而不是链表，所以就用<code>ne</code>数组表示连起来后下一条边的<code>idx</code>，<code>e</code>数组存的是<code>idx</code>这条边的入节点，<code>w</code>是这条边的权重。</p>
</blockquote>
<h4 id="遍历节点所连的边"><a class="markdownIt-Anchor" href="#遍历节点所连的边"></a> 遍历节点所连的边</h4>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = h[u]; i != <span class="hljs-number">-1</span>; i = ne[i]){<br>    <span class="hljs-keyword">do</span>...<br>}<br></code></pre></td></tr></tbody></table></figure>
<h4 id="图的dfs遍历"><a class="markdownIt-Anchor" href="#图的dfs遍历"></a> 图的DFS遍历</h4>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">bool</span> st[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span></span>{<br>    st[u] = <span class="hljs-literal">true</span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = h[u]; i != <span class="hljs-number">-1</span>; i = ne[i]){<br>        <span class="hljs-keyword">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span>(!st[j])<br>                <span class="hljs-built_in">dfs</span>(j);<br>    }<br>    <br>}<br></code></pre></td></tr></tbody></table></figure>
<h4 id="图的bfs遍历"><a class="markdownIt-Anchor" href="#图的bfs遍历"></a> 图的BFS遍历</h4>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//手写队列</span><br><span class="hljs-keyword">int</span> q[N];<br><span class="hljs-keyword">bool</span> st[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span>{<br>    <span class="hljs-comment">//初始化</span><br>    <span class="hljs-keyword">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">0</span>;<br>    q[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">while</span>(hh &lt;= tt){<br>        <span class="hljs-keyword">int</span> t = q[hh++];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i++){<br>            <span class="hljs-keyword">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span>(!st[j]){<br>                st[j] = <span class="hljs-literal">true</span>;<br>                q[++tt] = j;<br>            }<br>        }<br>    }<br>    <br>}<br></code></pre></td></tr></tbody></table></figure>
<h2 id="dfs"><a class="markdownIt-Anchor" href="#dfs"></a> DFS</h2>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/848/">846. 树的重心 - AcWing题库</a></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> M = <span class="hljs-number">2</span> * N;<br><br><span class="hljs-keyword">int</span> h[N], e[M], ne[M], idx; <br><span class="hljs-keyword">int</span> st[N];<br><span class="hljs-keyword">int</span> n;<br><br><span class="hljs-keyword">int</span> ans = N;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>{<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span></span>{ <span class="hljs-comment">//其实就是利用dfs可以求子树长度这一性质，对每个节点遍历求max的子树长度，然后和全局最小ans比较</span><br>    <br>    st[u] = <span class="hljs-literal">true</span>;<br>    <br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">1</span>, res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = h[u]; i != <span class="hljs-number">-1</span>; i = ne[i]){<br>        <span class="hljs-keyword">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span>(!st[j]){<br>            <span class="hljs-keyword">int</span> s = <span class="hljs-built_in">dfs</span>(j);<br>            res = <span class="hljs-built_in">max</span>(res, s);<br>            sum += s;<br>        }<br>    }<br>    <br>    res = <span class="hljs-built_in">max</span>(n - sum, res); <span class="hljs-comment">//n-sum表示除了该节点和其字数外的分支</span><br>    ans = <span class="hljs-built_in">min</span>(ans, res);<br>    <br>    <span class="hljs-keyword">return</span> sum;<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>{<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n<span class="hljs-number">-1</span>; i++){<br>        <span class="hljs-keyword">int</span> a, b;<br>        cin &gt;&gt; a &gt;&gt;b;<br>        <span class="hljs-built_in">add</span>(a, b), <span class="hljs-built_in">add</span>(b,a);<br>    }<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br>    <br>    cout &lt;&lt; ans &lt;&lt; endl;<br><br>    <br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   <br>}<br><br></code></pre></td></tr></tbody></table></figure>
<h2 id="bfs"><a class="markdownIt-Anchor" href="#bfs"></a> BFS</h2>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/849/">847. 图中点的层次 - AcWing题库</a></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">int</span> n, m;<br><br><span class="hljs-keyword">int</span> e[N], ne[N], h[N], idx;<br><span class="hljs-keyword">int</span> d[N], q[N];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>{<br>    e[idx] = b, ne[idx] = h[a] ,h[a] = idx++; <span class="hljs-comment">//建立邻接表的时候，用idx只是辅助建表，使用图的时候是不用idx的</span><br>}<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span>{<br>    <span class="hljs-keyword">int</span> hh=<span class="hljs-number">0</span>, tt =<span class="hljs-number">0</span>;<br>    <br>    q[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    d[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">while</span>(hh &lt;= tt){<br>        <span class="hljs-keyword">int</span> t = q[hh++];<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i]){<br>            <span class="hljs-keyword">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span>(d[j] == <span class="hljs-number">-1</span>){<br>                d[j] = d[t] + <span class="hljs-number">1</span>;<br>                q[++tt] = j;<br>            }<br>        }    <br>    }<br>    <br>    <span class="hljs-keyword">return</span> d[n];<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>{<br>    <br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">memset</span>(d, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> d);<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    <br>    <span class="hljs-keyword">int</span> a, b;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m ; i++){<br>        cin &gt;&gt; a &gt;&gt; b;<br>        <span class="hljs-built_in">add</span>(a,b);<br>    }<br>    <br>    cout &lt;&lt; <span class="hljs-built_in">bfs</span>() &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br><br><br></code></pre></td></tr></tbody></table></figure>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/850/">848. 有向图的拓扑序列 - AcWing题库</a></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">int</span> e[N], h[N], ne[N], idx;<br><span class="hljs-keyword">int</span> q[N], d[N];<br><span class="hljs-keyword">int</span> n, m;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>{<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx++;<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">topsort</span><span class="hljs-params">()</span></span>{<br>    <span class="hljs-keyword">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n; i++){<br>        <span class="hljs-keyword">if</span>(!d[i])<br>            q[++tt] = i;<br>    }<br>    <br>    <span class="hljs-keyword">while</span>(hh &lt;= tt){<br>        <span class="hljs-keyword">int</span> t = q[hh++];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i]){<br>            <span class="hljs-keyword">int</span> j = e[i];<br>            d[j]--;<br>            <span class="hljs-keyword">if</span>(!d[j])<br>                q[++tt] = j;<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> tt == n<span class="hljs-number">-1</span>;<br>}<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>{<br>    <br>    cin &gt;&gt; n &gt;&gt; m;<br>    <br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    <span class="hljs-built_in">memset</span>(d, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> d);<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++){<br>        <span class="hljs-keyword">int</span> a, b;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        <span class="hljs-built_in">add</span>(a, b);<br>        d[b]++;<br>    }<br>    <br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">topsort</span>()){<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,q[i]); <span class="hljs-comment">//如果有拓扑序列的话，q[N]就是</span><br>    }<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">"-1"</span>);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>
<h2 id="最短路"><a class="markdownIt-Anchor" href="#最短路"></a> 最短路</h2>
<h4 id="总体感知理解"><a class="markdownIt-Anchor" href="#总体感知理解"></a> 总体感知理解</h4>
<img src="https://i.loli.net/2021/11/27/tTSdoZQAC7kXML2.png" style="zoom:67%;">
<img src="https://i.loli.net/2021/11/27/StA1P9OMcDlWvzg.png" style="zoom:67%;">
<p><strong>Dijkstra</strong><br>
dijkstra算法本质上算是<strong>贪心</strong>的思想，每次在剩余节点中找到离起点最近的节点放到队列中，并用来更新剩下的节点的距离，再将它标记上表示已经找到到它的最短路径，以后不用更新它了。这样做的原因是到一个节点的最短路径必然会经过比它离起点更近的节点，而如果一个节点的当前距离值比任何剩余节点都小，那么当前的距离值一定是最小的。（剩余节点的距离值只能用当前剩余节点来更新，因为求出了最短路的节点之前已经更新过了）<br>
dijkstra就是这样不断从剩余节点中拿出一个可以确定最短路径的节点最终求得从起点到每个节点的最短距离。</p>
<p><strong>Bellman-Ford</strong><br>
bellman-ford算法进行n-1次更新（一次更新是指用所有边进行一次松弛操作，松弛是指取出一条边，尝试更新这条边起点到终点的距离）来找到到所有节点的单源最短路。bellman-ford算法和dijkstra其实有点相似，<strong>该算法能够保证每更新一次都能确定一个节点的最短路</strong>，但与dijkstra不同的是，<strong>并不知道是那个节点的最短路被确定了</strong>，只是知道比上次多确定一个，这样进行n-1次更新后所有节点的最短路都确定了（源点的距离本来就是确定的）。</p>
<blockquote>
<p>The longest possible shortest path from source <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span> to destination <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>v</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">v_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> can have <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi>V</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">−</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">|V|−1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord">∣</span><span class="mord">−</span><span class="mord">1</span></span></span></span> “stops”. According to <em>Lemma 24.15 Path-relaxation property</em> in CLRS, after each “relaxation” step, you get <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>i</mi><mo>=</mo><mi>δ</mi><mo stretchy="false">(</mo><mi>s</mi><mo separator="true">,</mo><mi>v</mi><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">vi=δ(s,vi)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span> and this value remains unchanged ever since. So after <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi>V</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">−</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">|V|−1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord">∣</span><span class="mord">−</span><span class="mord">1</span></span></span></span> times we must finish finding all results for a single-source shortest path problem. You make easily find a counterexample to say why loop for fewer than<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi>V</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">−</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">|V|−1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord">∣</span><span class="mord">−</span><span class="mord">1</span></span></span></span> will fail to find all shortest paths.</p>
</blockquote>
<p>现在来说明为什么每次更新都能多找到一个能确定最短路的节点：</p>
<blockquote>
<p>1.将所有节点分为两类：已知最短距离的节点和剩余节点。</p>
<p>2.这两类节点满足这样的性质：已知最短距离的节点的最短距离值都比剩余节点的最短路值小。（这一点也和dijkstra一样）</p>
<p>3.有了上面两点说明，易知到剩余节点的路径一定会经过已知节点</p>
<p>4.而从已知节点连到剩余节点的所有边中的最小的那个边，这条边所更新后的剩余节点就一定是确定的最短距离，从而就多找到了一个能确定最短距离的节点，不用知道它到底是哪个节点。</p>
</blockquote>
<p>bellman-ford的一个优势是可以用来判断是否存在负环，在不存在负环的情况下，进行了n-1次所有边的更新操作后每个节点的最短距离都确定了，再用所有边去更新一次不会改变结果。而如果存在负环，最后再更新一次会改变结果。原因是之前是假定了起点的最短距离是确定的并且是最短的，而又负环的情况下这个假设不再成立。</p>
<p><strong>Spfa</strong><br>
spfa可以看成是bellman-ford的队列优化版本，正如在前面讲到的，bellman每一轮用所有边来进行松弛操作可以多确定一个点的最短路径，但是用每次都把所有边拿来松弛太浪费了，不难发现，<strong>只有那些已经确定了最短路径的点所连出去的边才是有效的</strong>，因为新确定的点一定要先通过已知(最短路径的)节点。<br>
所以我们只需要把已知节点连出去的边用来松弛就行了，但是问题是我们并不知道哪些点是已知节点，不过我们可以放宽一下条件，找哪些可能是已知节点的点，也就是之前松弛后更新的点，已知节点必然在这些点中。<br>
所以spfa的做法就是把每次更新了的点放到队列中记录下来，类似于BFS。</p>
<h4 id="朴素dijkstra"><a class="markdownIt-Anchor" href="#朴素dijkstra"></a> 朴素Dijkstra</h4>
<img src="https://i.loli.net/2021/11/27/uxw6DPkdcqY39tp.png" style="zoom:67%;">
<h5 id="模板-2"><a class="markdownIt-Anchor" href="#模板-2"></a> 模板</h5>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*Dijkstra模板*/</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span>{<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">03</span>xf, siszeof dist);<span class="hljs-comment">//dist[i] &lt;- INF</span><br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span><span class="hljs-comment">//dist[1] &lt;- 0,</span><br>    <br>    <span class="hljs-keyword">for</span> i from <span class="hljs-number">1</span> to n<br>        t &lt;- <span class="hljs-number">-1</span>; <span class="hljs-comment">//每次都要初始化t</span><br>        <br>        <span class="hljs-keyword">for</span> j from <span class="hljs-number">1</span> to n <span class="hljs-comment">//把不在s中的距离最近的点赋值给t</span><br>            <span class="hljs-keyword">if</span>(!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[t] &gt; dist[j]) )<br>                t &lt;- j;<br>        <br>        st[t] = <span class="hljs-literal">true</span>; <span class="hljs-comment">//s &lt;- t</span><br>        <br>        <span class="hljs-keyword">for</span> j from <span class="hljs-number">1</span> to n<span class="hljs-comment">//用t更新其他点的距离</span><br>            <span class="hljs-keyword">if</span>(!st[j])<br>                dist[j] = <span class="hljs-built_in">min</span>(dist[j], dist[t] + g[t][j]);<br>    <br>        <br>        <span class="hljs-keyword">if</span>(dist[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> dist[n];<br>    <br>}<br><span class="hljs-comment">//ps:稠密图用邻接矩阵存</span><br></code></pre></td></tr></tbody></table></figure>
<h5 id="习题"><a class="markdownIt-Anchor" href="#习题"></a> 习题</h5>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/851/">849. Dijkstra求最短路 I - AcWing题库</a></p>
<blockquote>
<p>这题是要考虑重边的，注意看一下怎么处理的。</p>
</blockquote>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>  N = <span class="hljs-number">510</span>;<br><br><span class="hljs-keyword">int</span> g[N][N];<br><span class="hljs-keyword">int</span> dist[N];<br><span class="hljs-keyword">bool</span> st[N];<br><span class="hljs-keyword">int</span> n,m;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span>{<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++){<br>        <br>        <span class="hljs-keyword">int</span> t = <span class="hljs-number">-1</span>;    <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>            <span class="hljs-keyword">if</span>( !st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[t] &gt; dist[j]))<br>                t = j;<br>    <br>        st[t] = <span class="hljs-literal">true</span>;<br>    <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n ; j++)<br>            <span class="hljs-keyword">if</span>(!st[j])<br>                dist[j] = <span class="hljs-built_in">min</span>(dist[j], dist[t] + g[t][j]);<br><br>    }<br>    <span class="hljs-keyword">if</span>(dist[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <br>    <span class="hljs-keyword">return</span> dist[n];<br>}<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>{<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">memset</span>(g, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> g);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++){<br>        <span class="hljs-keyword">int</span> a, b, c;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>        g[a][b] = <span class="hljs-built_in">min</span>(g[a][b], c); <span class="hljs-comment">//处理重边</span><br>    }<br>    <span class="hljs-keyword">int</span> t = <span class="hljs-built_in">dijkstra</span>();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, t);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>
<h4 id="堆优化的dijkstra"><a class="markdownIt-Anchor" href="#堆优化的dijkstra"></a> 堆优化的Dijkstra</h4>
<blockquote>
<p>用优先队列模拟堆，这样的话堆里元素个数其实可能达到m个，也就是边数，这里应该注意st数组的判断的位置是放在了前面的，因为可能有重边的影响，所以要放在前面continue掉重边。</p>
<p>每次找到最小距离的点沿着边更新其他的点，若<code>dist[j] &gt; distance + w[i]</code>，表示可以更新<code>dist[j]</code>，更新后再把<code>j</code>点和对应的距离放入小根堆中。由于点的个数是<code>n</code>，边的个数是<code>m</code>，在极限情况下（稠密图<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>=</mo><mfrac><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mi mathvariant="normal">−</mi><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">m={n(n−1) \over 2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">n</span><span class="mord mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span>）。Dijkstra会遍历所有节点的所有边，其实就是遍历所有边，有<code>m</code>次，然后每遍历每条边的时候都要调整堆，堆里面最多有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>这么多边，因此每一次更新小根堆排序的情况是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><msup><mi>g</mi><msup><mi>n</mi><mn>2</mn></msup></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log^{n^2})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.23692em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9869199999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，一共最多<code>m</code>次更新，因此总的时间复杂度上限是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>l</mi><mi>o</mi><msup><mi>g</mi><msup><mi>n</mi><mn>2</mn></msup></msup><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mn>2</mn><mi>m</mi><mi>l</mi><mi>o</mi><msup><mi>g</mi><mi>n</mi></msup><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>l</mi><mi>o</mi><msup><mi>g</mi><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(mlog^{n^2})=O(2mlog^n)=O(mlog^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.23692em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9869199999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathdefault">m</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
</blockquote>
<h5 id="模板-3"><a class="markdownIt-Anchor" href="#模板-3"></a> 模板</h5>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*这个模板其实和BFS是有点像的*/</span><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; PII;<br><br><span class="hljs-keyword">int</span> n;      <span class="hljs-comment">// 点的数量</span><br><span class="hljs-keyword">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="hljs-comment">// 邻接表存储所有边，m,n数据范围是一样的</span><br><span class="hljs-keyword">int</span> dist[N];        <span class="hljs-comment">// 存储所有点到1号点的距离</span><br><span class="hljs-keyword">bool</span> st[N];     <span class="hljs-comment">// 存储每个点的最短距离是否已确定</span><br><br><span class="hljs-comment">// 求1号点到n号点的最短距离，如果不存在，则返回-1</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; <span class="hljs-comment">//小根堆</span><br>    heap.<span class="hljs-built_in">push</span>({<span class="hljs-number">0</span>, <span class="hljs-number">1</span>});      <span class="hljs-comment">// first存储距离，second存储节点编号</span><br><br>    <span class="hljs-keyword">while</span> (heap.<span class="hljs-built_in">size</span>()) <span class="hljs-comment">//while堆不空</span><br>    {<br>        <span class="hljs-keyword">auto</span> t = heap.<span class="hljs-built_in">top</span>(); <span class="hljs-comment">//每次取一个</span><br>        heap.<span class="hljs-built_in">pop</span>();<br><br>        <span class="hljs-keyword">int</span> ver = t.second, distance = t.first;<br><br>        <span class="hljs-keyword">if</span> (st[ver]) <span class="hljs-keyword">continue</span>;<br>        st[ver] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = h[ver]; i != <span class="hljs-number">-1</span>; i = ne[i]) <span class="hljs-comment">//对该节点遍历</span><br>        {<br>            <span class="hljs-keyword">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (dist[j] &gt; distance + w[i])<br>            {<br>                dist[j] = distance + w[i];<br>                heap.<span class="hljs-built_in">push</span>({dist[j], j});<br>            }<br>        }<br>    }<br><br>    <span class="hljs-keyword">if</span> (dist[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dist[n];<br>}<br></code></pre></td></tr></tbody></table></figure>
<h5 id="习题-2"><a class="markdownIt-Anchor" href="#习题-2"></a> 习题</h5>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/852/">850. Dijkstra求最短路 II - AcWing题库</a></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">150010</span>;<br><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; PII; <br><br><span class="hljs-keyword">int</span> h[N], e[N], ne[N], w[N], idx;<br><span class="hljs-keyword">int</span> dist[N];<br><span class="hljs-keyword">int</span> n,m;<br><span class="hljs-keyword">bool</span> st[N];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c)</span></span>{<br>    w[idx] = c;<br>    e[idx] = b;<br>    ne[idx] = h[a];<br>    h[a] = idx++; <span class="hljs-comment">//这个idx++一定要放到最后</span><br>}<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(dist));<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; <span class="hljs-comment">// 定义一个小根堆</span><br>    <span class="hljs-comment">// 这里heap中为什么要存pair呢，首先小根堆是根据距离来排的，所以有一个变量要是距离，其次在从堆中拿出来的时    </span><br>    <span class="hljs-comment">// 候要知道知道这个点是哪个点，不然怎么更新邻接点呢？所以第二个变量要存点。</span><br>    heap.<span class="hljs-built_in">push</span>({ <span class="hljs-number">0</span>, <span class="hljs-number">1</span> }); <span class="hljs-comment">// 这个顺序不能倒，pair排序时是先根据first，再根据second，这里显然要根据距离排序</span><br>    <span class="hljs-keyword">while</span>(heap.<span class="hljs-built_in">size</span>())<br>    {<br>        <span class="hljs-keyword">auto</span> t = heap.<span class="hljs-built_in">top</span>(); <span class="hljs-comment">// 取不在集合S中距离最短的点</span><br>        heap.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">int</span> ver = t.second, distance = t.first;<br><br>        <span class="hljs-keyword">if</span>(st[ver]) <span class="hljs-keyword">continue</span>;<br>        st[ver] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = h[ver]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>        {<br>            <span class="hljs-keyword">int</span> j = e[i]; <span class="hljs-comment">// i只是个下标，e中在存的是i这个下标对应的点。</span><br>            <span class="hljs-keyword">if</span>(dist[j] &gt; distance + w[i])<br>            {<br>                dist[j] = distance + w[i];<br>                heap.<span class="hljs-built_in">push</span>({ dist[j], j });<br>            }<br>        }<br>    }<br>    <span class="hljs-keyword">if</span>(dist[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> dist[n];<br>}<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>{<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(h));<br>    <span class="hljs-keyword">while</span>(m--){<br>        <span class="hljs-keyword">int</span> a, b, c;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>        <span class="hljs-built_in">add</span>(a, b, c);<br>    }<br><br><br>    <span class="hljs-keyword">int</span> t = <span class="hljs-built_in">dijkstra</span>();<br>    cout &lt;&lt; t &lt;&lt; endl;<br><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>
<h4 id="bellman-ford"><a class="markdownIt-Anchor" href="#bellman-ford"></a> Bellman-Ford</h4>
<img src="https://i.loli.net/2021/11/27/763Lcw4dTreKiuR.png" style="zoom:50%;">
<blockquote>
<p>Bellman-Ford可以处理有负权边的图，k次循环的意义是不超过k条边的最短路</p>
<p>看大佬的解释orz：<a target="_blank" rel="noopener" href="https://www.acwing.com/solution/AcWing/content/9188/">AcWing 853. Bellman_ford算法 - AcWing</a></p>
</blockquote>
<h5 id="模板-4"><a class="markdownIt-Anchor" href="#模板-4"></a> 模板</h5>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> n, m;       <span class="hljs-comment">// n表示点数，m表示边数</span><br><span class="hljs-keyword">int</span> dist[N];        <span class="hljs-comment">// dist[x]存储1到x的最短路距离</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span>     // 边，<span class="hljs-title">a</span>表示出点，<span class="hljs-title">b</span>表示入点，<span class="hljs-title">w</span>表示边的权重</span><br><span class="hljs-class">{</span><br>    <span class="hljs-keyword">int</span> a, b, w;<br>}edges[M];<br><br><span class="hljs-comment">// 求1到n的最短路距离，如果无法从1走到n，则返回-1。(这里的1换成节点i初始化就是到i的最短路了:leetcode787)</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bellman_ford</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>    {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j ++ )<br>        {<br>            <span class="hljs-keyword">int</span> a = edges[j].a, b = edges[j].b, w = edges[j].w;<br>            <span class="hljs-keyword">if</span> (dist[b] &gt; dist[a] + w)<br>                dist[b] = dist[a] + w;<br>        }<br>    }<br><br>    <span class="hljs-keyword">if</span> (dist[n] &gt; <span class="hljs-number">0x3f3f3f3f</span> / <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dist[n];<br>}<br></code></pre></td></tr></tbody></table></figure>
<h5 id="习题-3"><a class="markdownIt-Anchor" href="#习题-3"></a> 习题</h5>
<blockquote>
<p>注意：有边数限制的题目要在以上模板的基础上加个备份数组，防止数据被污染。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/855/">853. 有边数限制的最短路 - AcWing题库</a></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> M = <span class="hljs-number">1e4</span> + <span class="hljs-number">10</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">510</span>;<br><span class="hljs-keyword">int</span> n, m, k;<br><span class="hljs-keyword">int</span> back[N], dist[N];<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span>{</span><br>    <span class="hljs-keyword">int</span> a, b, c;<br>}e[M];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bellman_ford</span><span class="hljs-params">()</span></span>{<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++){<br>        <span class="hljs-built_in">memcpy</span>( back, dist, <span class="hljs-keyword">sizeof</span> dist);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++){<br>            <span class="hljs-keyword">int</span> a = e[j].a, b = e[j].b, w = e[j].c;<br>            <span class="hljs-keyword">if</span>(dist[b] &gt; w + back[a])<br>                dist[b] = w + back[a];<br>        }<br>    }<br>    <br>    <span class="hljs-keyword">return</span> dist[n];<br>    <br>}<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>{<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ;i &lt; m; i++)<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d%d"</span>, &amp;e[i].a,&amp;e[i].b,&amp;e[i].c);<br>    <br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-built_in">bellman_ford</span>();<br>    <span class="hljs-keyword">if</span>(ans &gt; <span class="hljs-number">0x3f3f3f3f</span> /<span class="hljs-number">2</span> ) <span class="hljs-built_in">puts</span>(<span class="hljs-string">"impossible"</span>);<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; ans &lt;&lt; endl;<br>    <br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>
<h4 id="spfa"><a class="markdownIt-Anchor" href="#spfa"></a> Spfa</h4>
<blockquote>
<p>Spfa优化了Bellman-Ford算法，具体来说就是只考虑可以松弛的边。</p>
<p>看大佬orz：<a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/9306/">AcWing 851. SPFA算法 - AcWing</a></p>
</blockquote>
<h5 id="模板-5"><a class="markdownIt-Anchor" href="#模板-5"></a> 模板</h5>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">int</span> h[N], e[N], ne[N], idx, w[N];<br><span class="hljs-keyword">int</span> st[N], dist[N];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span>{<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <br>    queue&lt;<span class="hljs-keyword">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>    st[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>    <br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()){<br>        <span class="hljs-keyword">int</span> t = q.front;<br>        q.<span class="hljs-built_in">pop</span>();<br>        st[t] = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = h[t], i != <span class="hljs-number">-1</span>; i =ne[i]){<br>            <span class="hljs-keyword">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span>(dist[j] &gt; dist[t] + w[i]){<br>                dist[j] = dist[t] + w[i];<br>                <span class="hljs-keyword">if</span>(!st[j]){<br>                    st[j] = <span class="hljs-literal">true</span>;<br>                    q.<span class="hljs-built_in">push</span>(j);<br>                }<br>            }<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> dist[n]; <span class="hljs-comment">//return到main函数里判断一下</span><br><br>}<br></code></pre></td></tr></tbody></table></figure>
<h5 id="习题-4"><a class="markdownIt-Anchor" href="#习题-4"></a> 习题</h5>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/853/">851. spfa求最短路 - AcWing题库</a></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">int</span> h[N], ne[N], e[N], idx, w[N];<br><span class="hljs-keyword">int</span> st[N], dist[N];<br><span class="hljs-keyword">int</span> n, m;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span>{<br>    queue&lt;<span class="hljs-keyword">int</span>&gt; q;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>    st[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()){<br>        <span class="hljs-keyword">int</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        st[t] = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i]){<br>            <span class="hljs-keyword">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span>(dist[j] &gt; dist[t] + w[i]){<br>                dist[j] = dist[t] + w[i];<br>                <span class="hljs-keyword">if</span>(!st[j]){<br>                    st[j] = <span class="hljs-literal">true</span>;<br>                    q.<span class="hljs-built_in">push</span>(j);<br>                }<br>            }<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> dist[n];<br>}<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c)</span></span>{<br>    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx++;<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>{<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">memset</span>(h , <span class="hljs-number">-1</span> , <span class="hljs-keyword">sizeof</span> h);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++){<br>        <span class="hljs-keyword">int</span> a, b ,c;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt;c;<br>        <span class="hljs-built_in">add</span>(a, b ,c);<br>    }<br>    <br>    <span class="hljs-keyword">int</span> t = <span class="hljs-built_in">spfa</span>();<br>    <br>    <span class="hljs-keyword">if</span>(t == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">"impossible"</span>);<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; dist[n] &lt;&lt; endl;<br>    <br>    <br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/problem/content/921/">AcWing 852. spfa判断负环 - AcWing</a></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">int</span> h[N], ne[N], e[N], idx, w[N];<br><span class="hljs-keyword">int</span> st[N], dist[N], cnt[N];<br><span class="hljs-keyword">int</span> n, m;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span>{<br>    queue&lt;<span class="hljs-keyword">int</span>&gt; q;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++){<br>        st[i] = <span class="hljs-literal">true</span>;<br>        q.<span class="hljs-built_in">push</span>(i);<br>    }<br>    <br><br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()){<br>        <span class="hljs-keyword">int</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        st[t] = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i]){<br>            <span class="hljs-keyword">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span>(dist[j] &gt; dist[t] + w[i]){<br>                dist[j] = dist[t] + w[i];<br>                cnt[j] = cnt[t] + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span>(cnt[j] &gt;= n) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">if</span>(!st[j]){<br>                    st[j] = <span class="hljs-literal">true</span>;<br>                    q.<span class="hljs-built_in">push</span>(j);<br>                }<br>            }<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>}<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c)</span></span>{<br>    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx++;<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>{<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">memset</span>(h , <span class="hljs-number">-1</span> , <span class="hljs-keyword">sizeof</span> h);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++){<br>        <span class="hljs-keyword">int</span> a, b ,c;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt;c;<br>        <span class="hljs-built_in">add</span>(a, b ,c);<br>    }<br>    <br>    <span class="hljs-keyword">int</span> t = <span class="hljs-built_in">spfa</span>();<br>    <br>    <span class="hljs-keyword">if</span>(t == <span class="hljs-literal">false</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">"No"</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Yes"</span>);<br>    <br>    <br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>
<h4 id="floyd"><a class="markdownIt-Anchor" href="#floyd"></a> Floyd</h4>
<h5 id="模板-6"><a class="markdownIt-Anchor" href="#模板-6"></a> 模板</h5>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//初始化：</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br>            <span class="hljs-keyword">if</span> (i == j) d[i][j] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span> d[i][j] = INF;<br><br><span class="hljs-comment">// 算法结束后，d[a][b]表示a到b的最短距离</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br>                d[i][j] = <span class="hljs-built_in">min</span>(d[i][j], d[i][k] + d[k][j]);<br>}<br></code></pre></td></tr></tbody></table></figure>
<h5 id="习题-5"><a class="markdownIt-Anchor" href="#习题-5"></a> 习题</h5>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">210</span>, INF = <span class="hljs-number">1e9</span>;<br><span class="hljs-keyword">int</span> n, m, k;<br><span class="hljs-keyword">int</span> d[N][N];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span></span>{<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k ++){<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++){<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>                d[i][j] = <span class="hljs-built_in">min</span>(d[i][j], d[i][k] + d[k][j]);<br>        }<br>    }<br>    <br>}<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>{<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++){<br>            <span class="hljs-keyword">if</span>(i == j) d[i][j] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span> d[i][j] = INF;<br>        }<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++){<br>        <span class="hljs-keyword">int</span> a, b, c;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>        d[a][b] = <span class="hljs-built_in">min</span>(d[a][b], c);<br>    }<br>    <br>    <span class="hljs-built_in">floyd</span>();<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++){<br>        <span class="hljs-keyword">int</span> a, b;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        <span class="hljs-keyword">if</span>(d[a][b] &gt; INF /<span class="hljs-number">2</span> )    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"impossible"</span>);<br>        <span class="hljs-keyword">else</span>    cout &lt;&lt; d[a][b] &lt;&lt; endl;<br>    }<br>    <br>    <br>    <br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>
<h2 id="最小生成树"><a class="markdownIt-Anchor" href="#最小生成树"></a> 最小生成树</h2>
<img src="https://i.loli.net/2021/11/27/VctAGwOoC7DsQBz.png" style="zoom: 67%;">
<h4 id="朴素prim"><a class="markdownIt-Anchor" href="#朴素prim"></a> 朴素Prim</h4>
<h5 id="模板-7"><a class="markdownIt-Anchor" href="#模板-7"></a> 模板</h5>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> g[N][N]; <span class="hljs-comment">//邻接矩阵</span><br><span class="hljs-keyword">int</span> dist[N]; <span class="hljs-comment">//到集合的距离</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">prim</span><span class="hljs-params">()</span></span>{<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++){<br>        <br>        <span class="hljs-keyword">int</span> t = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>            <span class="hljs-keyword">if</span>(!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[t] &gt; dist[j]))<br>                t = j;<br>        <br>        <span class="hljs-keyword">if</span>(dist[t] == INF) <span class="hljs-keyword">return</span> INF; <span class="hljs-comment">//不连通</span><br>        <br>        st[t] = <span class="hljs-literal">true</span>;<br>        ans += dist[t]; <br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>                dist[j] = <span class="hljs-built_in">min</span>(dist[j], g[t][j]);<br>        <br>    }<br>    <span class="hljs-keyword">return</span> ans;<br>}<br></code></pre></td></tr></tbody></table></figure>
<h5 id="习题-6"><a class="markdownIt-Anchor" href="#习题-6"></a> 习题</h5>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/860/">858. Prim算法求最小生成树 - AcWing题库</a></p>
<h4 id="kruskal"><a class="markdownIt-Anchor" href="#kruskal"></a> Kruskal</h4>
<p>并查集知识点</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/839/">837. 连通块中点的数量 - AcWing题库</a></p>
<img src="https://i.loli.net/2021/11/27/s7HNU2xEITdeBrR.png" style="zoom: 67%;">
<h5 id="模板-8"><a class="markdownIt-Anchor" href="#模板-8"></a> 模板</h5>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> n, m;       <span class="hljs-comment">// n是点数，m是边数</span><br><span class="hljs-keyword">int</span> p[N];       <span class="hljs-comment">// 并查集的父节点数组</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span>     // 存储边</span><br><span class="hljs-class">{</span><br>    <span class="hljs-keyword">int</span> a, b, w;<br><br>    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt; (<span class="hljs-keyword">const</span> Edge &amp;W)<span class="hljs-keyword">const</span> <span class="hljs-comment">//运算符重载</span><br>    {<br>        <span class="hljs-keyword">return</span> w &lt; W.w;<br>    }<br>}edges[M];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span>     <span class="hljs-comment">// 并查集核心操作</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-keyword">if</span> (p[x] != x) p[x] = <span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">kruskal</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-built_in">sort</span>(edges, edges + m);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) p[i] = i;    <span class="hljs-comment">// 初始化并查集</span><br><br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i ++ )<br>    {<br>        <span class="hljs-keyword">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;<br><br>        a = <span class="hljs-built_in">find</span>(a), b = <span class="hljs-built_in">find</span>(b);<br>        <span class="hljs-keyword">if</span> (a != b)     <span class="hljs-comment">// 如果两个连通块不连通，则将这两个连通块合并</span><br>        {<br>            p[a] = b;<br>            res += w;<br>            cnt ++ ;<br>        }<br>    }<br><br>    <span class="hljs-keyword">if</span> (cnt &lt; n - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> INF;<br>    <span class="hljs-keyword">return</span> res;<br>}<br></code></pre></td></tr></tbody></table></figure>
<h5 id="习题-7"><a class="markdownIt-Anchor" href="#习题-7"></a> 习题</h5>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/861/">859. Kruskal算法求最小生成树 - AcWing题库</a></p>
<h2 id="二分图"><a class="markdownIt-Anchor" href="#二分图"></a> 二分图</h2>
<h4 id="二分图染色"><a class="markdownIt-Anchor" href="#二分图染色"></a> 二分图染色</h4>
<p><strong>模板</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> n;      <span class="hljs-comment">// n表示点数</span><br><span class="hljs-keyword">int</span> h[N], e[M], ne[M], idx;     <span class="hljs-comment">// 邻接表存储图</span><br><span class="hljs-keyword">int</span> color[N];       <span class="hljs-comment">// 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色</span><br><br><span class="hljs-comment">// 参数：u表示当前节点，c表示当前点的颜色</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> c)</span></span><br><span class="hljs-function"></span>{<br>    color[u] = c;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = h[u]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>    {<br>        <span class="hljs-keyword">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (color[j] == <span class="hljs-number">-1</span>)<br>        {<br>            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">dfs</span>(j, !c)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        }<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (color[j] == c) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    }<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-built_in">memset</span>(color, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> color);<br>    <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">if</span> (color[i] == <span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">dfs</span>(i, <span class="hljs-number">0</span>))<br>            {<br>                flag = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>            }<br>    <span class="hljs-keyword">return</span> flag;<br>}<br></code></pre></td></tr></tbody></table></figure>
<p><strong>习题</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/problem/content/926/">AcWing 860. 染色法判定二分图 - AcWing</a></p>
<h4 id="匈牙利算法"><a class="markdownIt-Anchor" href="#匈牙利算法"></a> 匈牙利算法</h4>
<blockquote>
<p>可以结合这个gif理解递归的过程<a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/5334/">AcWing 861. 二分图的最大匹配 - AcWing</a></p>
</blockquote>
<p><strong>模板</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> n1, n2;     <span class="hljs-comment">// n1表示第一个集合中的点数，n2表示第二个集合中的点数</span><br><span class="hljs-keyword">int</span> h[N], e[M], ne[M], idx;     <span class="hljs-comment">// 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边</span><br><span class="hljs-keyword">int</span> match[N];       <span class="hljs-comment">// 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个</span><br><span class="hljs-keyword">bool</span> st[N];     <span class="hljs-comment">// 表示第二个集合中的每个点是否已经被遍历过</span><br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = h[x]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>    {<br>        <span class="hljs-keyword">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (!st[j])<br>        {<br>            st[j] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (match[j] == <span class="hljs-number">0</span> || <span class="hljs-built_in">find</span>(match[j]))<br>            {<br>                match[j] = x;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            }<br>        }<br>    }<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>}<br><br><span class="hljs-comment">// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点</span><br><span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n1; i ++ ) <span class="hljs-comment">//这个注意要是从1开始的，不然match[0] = 0会出现bug</span><br>{<br>    <span class="hljs-built_in">memset</span>(st, <span class="hljs-literal">false</span>, <span class="hljs-keyword">sizeof</span> st);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">find</span>(i)) res ++ ;<br>}<br><span class="hljs-comment">//可能会问说不是两个集合的点么，下标怎么不区分，实际上可以这么理解，就是把刻板印象自环理解为两个标号相同的点连边，两个点分别位于两个集合，这样去理解是不冲突的。</span><br></code></pre></td></tr></tbody></table></figure>
<p><strong>习题</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/863/">861. 二分图的最大匹配 - AcWing题库</a></p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/2284/">2282. 假期的宿舍 - AcWing题库</a></p>
<h2 id="最大流"><a class="markdownIt-Anchor" href="#最大流"></a> 最大流</h2>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41505957/article/details/103254238?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.no_search_link">(36条消息) 网络流之最大流算法总结（FF， EK， Dinic）_张宜强的博客-CSDN博客</a></p>
<h4 id="ford-fullkerson"><a class="markdownIt-Anchor" href="#ford-fullkerson"></a> Ford-Fullkerson</h4>
<h5 id="模板-9"><a class="markdownIt-Anchor" href="#模板-9"></a> 模板</h5>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//先挖个坑</span><br><span class="hljs-comment">//n,m,s,t，分别表示点的个数、有向边的个数、源点序号、汇点序号</span><br>INF &lt;- <span class="hljs-number">1e9</span>;<br><br><span class="hljs-comment">//不断更新余图，增加流量</span><br><span class="hljs-built_in">MAX_FLOW</span>(s, t){<br>    flow &lt;- <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">WHILE</span>(<span class="hljs-number">1</span>){<br>        FOR i &lt;- <span class="hljs-number">0</span> To n<span class="hljs-number">-1</span><br>            st[i] &lt;- <span class="hljs-literal">false</span>; <span class="hljs-comment">//初始化</span><br>        f &lt;- <span class="hljs-built_in">dfs</span>(s, t, INF); <br>        IF f == <span class="hljs-number">0</span> THEN<br>            <span class="hljs-keyword">return</span> flow;<br>        flow &lt;- flow + f;<br>    }<br>}<br><br><span class="hljs-comment">//找余图的增广路径，更新余图，并返回该路径的流量</span><br><span class="hljs-built_in">DFS</span>(v, t, f){<br>    IF v == t THEN <span class="hljs-comment">//到达汇点</span><br>        <span class="hljs-keyword">return</span> f;<br>    <span class="hljs-comment">//dfs</span><br>    st[v] &lt;- <span class="hljs-literal">true</span>;<br>    FOR i &lt;- <span class="hljs-number">0</span> To n<br>        e &lt;- edge[v][i]; <span class="hljs-comment">//s点连的边</span><br>        k &lt;- e.vertice; <span class="hljs-comment">//e的出节点</span><br>        <span class="hljs-built_in">IF</span>(!st[k] &amp;&amp; e.w &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">//e.w是这条边的权值</span><br>            d &lt;- <span class="hljs-built_in">dfs</span>(k, t, <span class="hljs-built_in">min</span>(f, e.w));<br>            IF d TEHN <span class="hljs-comment">//更新正向边和反向边</span><br>                e.w &lt;- e.w -d;<br>                e.inverse_w &lt;- e.inverse_w + d;<br>                <span class="hljs-keyword">return</span> d;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></tbody></table></figure>
<h5 id="习题-8"><a class="markdownIt-Anchor" href="#习题-8"></a> 习题</h5>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3376">P3376 【模板】网络最大流 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<h1 id="搜索"><a class="markdownIt-Anchor" href="#搜索"></a> 搜索</h1>
<h2 id="搜索漫谈"><a class="markdownIt-Anchor" href="#搜索漫谈"></a> 搜索漫谈</h2>
<blockquote>
<p>First question: What is search?</p>
<p>Is it just a way of finding paths on a map?🤔</p>
<p>No🤗, and actually search is about making choices.</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Search_algorithm">搜索</a>大概可以理解为在search space里去寻找符合目标的解，也就是通过决策来去达到目标。</p>
<blockquote>
<p>这个search space还真不等同于solution space，但是对于optimal问题的话，应该是the domain of the function to be optimized，也就是solution space 。</p>
</blockquote>
<p>搜索其实可以理解为解决问题的一种范式，其实这也是和数学的那种思维不一样的点，数学的思维就是一下子启发性地找到了解决问题的特定思路，而且比较优美。而实际上，很多计算问题是没办法给出特定的公式来指定决策的，并没有说一种对于问题各种变式的统一解法。这其实就应该考虑计算思维，也就是利用算法去实现。首先可以考虑朴素穷举的思维，没有利用问题的特性，也没有考虑启发式设计的那种brute force；然后再去看这个问题有没有其他的设计模式，比如对于optimal问题，有没有优化子结构，能不能用dp和贪心；或者仅仅对于搜索策略，能不能添加启发式方法，以及利用其他方法进行优化。</p>
<p>search can solve lots of different kinds of problems，比较常见的有<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Combinatorial_optimization">组合优化问题</a>，<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Constraint_satisfaction">约束满足问题</a>。举个例子就很容易理解了，背包问题，最短路问题，后面的小猫爬山习题就是组合优化问题，而八皇后，四色问题这种就属于约束满足问题。</p>
<p>对于组合优化问题，首先来看一下解空间的定义<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Feasible_region">(●’◡’●)</a>， 然后具体的话，先看这个组合优化问题可不可能用dp和贪心整了，要是不行，就考虑搜索，而搜索其实就是 for these points in the solution space, choose a right search sequence that generates the search space which can cover the hole solution space and the elements in it exhaustedly. 但是也不能是爆搜，所以对于搜索，也是要有具体的一些优化方法的。</p>
<h2 id="搜索的优化"><a class="markdownIt-Anchor" href="#搜索的优化"></a> 搜索的优化</h2>
<p>搜索大概分为<strong>search for a good answer</strong>和<strong>search for the optimal answer</strong>。</p>
<p>对于搜索一个answer的情况大概有以下的讨论：</p>
<p>首先肯定是从爆搜开始优化，在歪果叫做British Museum algorithm，这个算法的消耗就和算法名字一样huge。</p>
<p>然后考虑优化，How can i do better？</p>
<p>先从搜索顺序入手，可以分为从深度入手和从广度入手，然后加上enqueued list也就是对于一个元素只访问一次，相当于st数组的作用，也就是平时用的深搜和宽搜，深搜还有个backtracking的特性。</p>
<p>对于search for a good answer，我们关注的是how far is it to the answer point，可以考虑启发式也就是admissible heuristic，去扩展目前最有可能到达目标的节点。</p>
<img src="https://i.loli.net/2021/12/03/qPRHo2ptJ8M6r9y.png" style="zoom:50%;">
<blockquote>
<p>这里Hill Climbing 的backtracking是防止走到死胡同，找到答案后是不会再去backtracking了。</p>
</blockquote>
<img src="https://i.loli.net/2021/12/03/lpQ1B9PJIHN7qzF.jpg" style="zoom:67%;">
<p>Hill-climbing类似于depth first，在queue front的那条路径上进行扩展，每次选择最优的，直到死胡同回溯出队or找到good solution.</p>
<p>Hill-climbing searches work by starting off with an initial guess of a solution, then iteratively making local changes to it until either the solution is found or the heuristic gets stuck in a local maximum. There are many ways to try to avoid getting stuck in local maxima, such as running many searches in parallel, or probabilistically choosing the successor state, etc. In many cases, hill-climbing algorithms will rapidly converge on the correct answer. However, none of these approaches are guaranteed to find the optimal solution.</p>
<p>Branch-and-bound solutions work by cutting the search space into pieces, exploring one piece, and then attempting to rule out other parts of the search space based on the information gained during each search. They are guaranteed to find the optimal answer eventually, though doing so might take a long time. For many problems, branch-and-bound based algorithms work quite well, since a small amount of information can rapidly shrink the search space.</p>
<p>In short, hill-climbing isn’t guaranteed to find the right answer, but often runs very quickly and gives good approximations. Branch-and-bound always finds the right answer, but might take a while to do so.</p>
<p>而对于search for the optimal answer，我们关注的是how long have we traveled.可以利用branch and bound分支界限来最优化剪枝(mit这里应该是把branch and bound定义成best-first和剪枝)，另外也可以通过启发式函数进行优化。而<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>A</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">A^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.688696em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span>算法就可以看为branch&amp;bound + extended list + admissible heuristic。</p>
<p>find a good answer考虑的是enqueued list, 而find an optimal answer考虑的是extended list.</p>
<p>A node is enqueued does not mean that it is extended. In fact, we can enqueue many times the same node, but with different distance value each time, they are just candidates for extension. And we just choose the shortest for extension.</p>
<p><img src="https://i.loli.net/2021/12/03/qIxZRv7E36SLfwh.png" alt=""></p>
<blockquote>
<p>differences between find a good path and find a best path.</p>
</blockquote>
<p><img src="https://i.loli.net/2021/12/03/MrYTps3AIF64yXP.png" alt=""></p>
<h2 id="搜索习题"><a class="markdownIt-Anchor" href="#搜索习题"></a> 搜索习题</h2>
<h4 id="爆搜dfs"><a class="markdownIt-Anchor" href="#爆搜dfs"></a> 爆搜DFS</h4>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/844/">842. 排列数字 - AcWing题库</a></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//按层数的顺序去搜索</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> path[N];<br><span class="hljs-keyword">bool</span> st[N];<br><span class="hljs-keyword">int</span> n;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span></span>{ <span class="hljs-comment">//u是层数</span><br>    <br>    <span class="hljs-keyword">if</span>(u == n){<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i= <span class="hljs-number">0</span>; i &lt; n; i++)  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,path[i]); <span class="hljs-comment">//按层数打印</span><br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">""</span>);<br>        <span class="hljs-keyword">return</span>;<br>    }<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++){ <span class="hljs-comment">//对每个元素枚举</span><br>        <span class="hljs-keyword">if</span>(!st[i]){<br>            path[u] = i;<br>            st[i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">dfs</span>(u+<span class="hljs-number">1</span>);<br>            st[i] = <span class="hljs-literal">false</span>;<br>        }<br>    }<br>}<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>{<br>    cin &gt;&gt; n;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/845/">843. n-皇后问题 - AcWing题库</a></p>
<p>思路一：全排列式搜索顺序，时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">!</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n!)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">!</span><span class="mclose">)</span></span></span></span>级。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">20</span>; <span class="hljs-comment">//注意那个dg和udg其实是mapping的，数组要开大一点</span><br><span class="hljs-keyword">char</span> g[N][N]; <span class="hljs-comment">//棋盘</span><br><span class="hljs-keyword">bool</span> col[N], dg[N], udg[N]; <span class="hljs-comment">//行，列，对角线</span><br><span class="hljs-keyword">int</span> n;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span></span>{ <span class="hljs-comment">//每一层，也就是每一行</span><br>    <br>    <span class="hljs-keyword">if</span>(u == n){<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) <span class="hljs-built_in">puts</span>(g[i]);<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">""</span>);<br>        <span class="hljs-keyword">return</span>;<br>    }<br>            <br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++){<br>        <span class="hljs-keyword">if</span>(!col[i] &amp;&amp; !dg[i+u] &amp;&amp; !udg[n-i+u]){<br>            g[u][i] = <span class="hljs-string">'Q'</span>;<br>            col[i] = dg[i+u] = udg[n-i+u] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">dfs</span>(u+<span class="hljs-number">1</span>);<br>            g[u][i] = <span class="hljs-string">'.'</span>;<br>            col[i] = dg[i+u] = udg[n-i+u] = <span class="hljs-literal">false</span>;<br>        }<br>    }<br>    <br>}<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>{<br>    cin &gt;&gt; n;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>            g[i][j] = <span class="hljs-string">'.'</span>; <span class="hljs-comment">//进行初始化</span><br>    <br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>);<br>    <br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>思路二：对每个位置进行枚举，时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mn>2</mn><msup><mi>n</mi><mn>2</mn></msup></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(2^{n^2})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.23692em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9869199999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>级别</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">20</span>; <span class="hljs-comment">//注意那个dg和udg其实是mapping的，数组要开大一点</span><br><span class="hljs-keyword">char</span> g[N][N]; <span class="hljs-comment">//棋盘</span><br><span class="hljs-keyword">bool</span> row[N], col[N], dg[N], udg[N]; <span class="hljs-comment">//行，列，对角线</span><br><span class="hljs-keyword">int</span> n;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> s)</span></span>{ <span class="hljs-comment">// x,y是表示格子，s是皇后的个数</span><br>    <span class="hljs-keyword">if</span>(y == n){ <span class="hljs-comment">//处理出界情况</span><br>        x += <span class="hljs-number">1</span>;<br>        y = <span class="hljs-number">0</span>;<br>    }<br>    <br>    <span class="hljs-keyword">if</span>(x == n){ <span class="hljs-comment">//搜索完了而且皇后也放完了</span><br>        <span class="hljs-keyword">if</span>(s == n){<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>                    <span class="hljs-built_in">puts</span>(g[i]);<br>                <span class="hljs-built_in">puts</span>(<span class="hljs-string">""</span>);<br>        }<br>        <span class="hljs-keyword">return</span>;<br>    }<br><br>    <span class="hljs-keyword">if</span>(!row[x] &amp;&amp; !col[y] &amp;&amp; !dg[x+y] &amp;&amp; !udg[x-y+n]){<br>        g[x][y] = <span class="hljs-string">'Q'</span>;<br>        col[y] = dg[x+y] = udg[n-y+x] = row[x] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-built_in">dfs</span>(x,y+<span class="hljs-number">1</span>,s+<span class="hljs-number">1</span>);<br>        g[x][y] = <span class="hljs-string">'.'</span>;<br>        col[y] = dg[x+y] = udg[n-y+x] = row[x] = <span class="hljs-literal">false</span>;<br>    }<br>    <br>    <span class="hljs-comment">// 不放皇后</span><br>    <span class="hljs-built_in">dfs</span>(x, y+<span class="hljs-number">1</span>, s);<br>    <br>}<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>{<br>    cin &gt;&gt; n;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>            g[i][j] = <span class="hljs-string">'.'</span>; <span class="hljs-comment">//进行初始化</span><br>    <br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>    <br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/167/">165. 小猫爬山 - AcWing题库</a></p>
<p>小猫爬山其实是和八皇后的思路2有点像，也是对每个状态进行枚举</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">20</span>;<br><br><span class="hljs-keyword">int</span> cat[N], sum[N]; <br><span class="hljs-keyword">int</span> ans = N;<br><span class="hljs-keyword">int</span> n, m; <span class="hljs-comment">//小猫总数和重量限制</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> k)</span></span>{ <span class="hljs-comment">//k辆车，0~k-1</span><br>    <span class="hljs-keyword">if</span>(k &gt;= ans) <span class="hljs-keyword">return</span>;<br>    <br>    <span class="hljs-keyword">if</span>(u == n){<br>        ans = k;<br>        <span class="hljs-keyword">return</span>;<br>    }<br>    <br>    <span class="hljs-comment">//放到以前的车子里</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++){<br>        <span class="hljs-keyword">if</span>(sum[i] + cat[u] &lt;= m){<br>            sum[i] += cat[u];<br>            <span class="hljs-built_in">dfs</span>(u+<span class="hljs-number">1</span>, k);<br>            sum[i] -= cat[u];<br>        }<br>    }    <br>    <br>    <span class="hljs-comment">//开新车</span><br>    sum[k] = cat[u];<br>    <span class="hljs-built_in">dfs</span>(u+<span class="hljs-number">1</span>, k+<span class="hljs-number">1</span>);<br>    sum[k] = <span class="hljs-number">0</span>;<br>    <br>}<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>{<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;cat[i]);<br>    <span class="hljs-built_in">sort</span>(cat, cat+n);<br>    <span class="hljs-built_in">reverse</span>(cat, cat+n);<br>    <br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>
<h4 id="迷宫型-bfs"><a class="markdownIt-Anchor" href="#迷宫型-bfs"></a> 迷宫型 BFS</h4>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/846/">844. 走迷宫 - AcWing题库</a></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">105</span>;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; PII;<br><br>PII q[N * N], path[N][N];<br><br><span class="hljs-keyword">int</span> n, m;<br><span class="hljs-keyword">int</span> g[N][N], d[N][N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span>{<br>    <span class="hljs-keyword">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">0</span>; <span class="hljs-comment">//队头和队尾</span><br>    q[<span class="hljs-number">0</span>] = {<span class="hljs-number">0</span>,<span class="hljs-number">0</span>};   <span class="hljs-comment">//队列里面存的是pair，也就是点的坐标</span><br>    <br>    <span class="hljs-built_in">memset</span>(d, <span class="hljs-number">-1</span> , <span class="hljs-keyword">sizeof</span> d);<br>    d[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">int</span> dx[<span class="hljs-number">4</span>]={<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>}, dy[<span class="hljs-number">4</span>]={<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>};<br>    <span class="hljs-keyword">while</span>(hh &lt;= tt){<br>        <span class="hljs-keyword">auto</span> t = q[hh++];<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++){<br>            <span class="hljs-keyword">int</span> x = t.first + dx[i], y = t.second + dy[i];<br>            <span class="hljs-keyword">if</span>(x &gt;= <span class="hljs-number">0</span> &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &lt; m &amp;&amp; g[x][y] == <span class="hljs-number">0</span> &amp;&amp; d[x][y] == <span class="hljs-number">-1</span>){<br>                <span class="hljs-comment">//path[x][y]= t; //输出路径</span><br>                d[x][y] = d[t.first][t.second] + <span class="hljs-number">1</span>;<br>                q[++tt] = {x,y};<br>            }<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> d[n <span class="hljs-number">-1</span>][m <span class="hljs-number">-1</span>];<br>}<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>{<br><br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++)<br>            cin &gt;&gt; g[i][j];<br>    <br><br>    cout &lt;&lt; <span class="hljs-built_in">bfs</span>() &lt;&lt; endl;<br>    <br>    <span class="hljs-comment">//输出路径        </span><br>    <span class="hljs-comment">// int x = n-1, y = m-1;</span><br>    <span class="hljs-comment">// while(x || y){</span><br>    <span class="hljs-comment">//     cout &lt;&lt; x &lt;&lt; ',' &lt;&lt; y &lt;&lt; endl;</span><br>    <span class="hljs-comment">//     int tempx = path[x][y].first, tempy = path[x][y].second;</span><br>    <span class="hljs-comment">//     x = tempx, y =tempy;</span><br>    <span class="hljs-comment">// }</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></tbody></table></figure>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/video/277/">AcWing 845. 八数码 - AcWing</a></p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;unordered_map&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">(string start)</span></span>{<br>    string end = <span class="hljs-string">"12345678x"</span>;<br>    <br>    <span class="hljs-comment">//map一下，把状态对应到节点，每个节点对应一个距离</span><br>    unordered_map&lt;string, <span class="hljs-keyword">int</span>&gt; d;<br>    d[start] = <span class="hljs-number">0</span>;<br>    <br>    queue&lt;string&gt; q;<br>    q.<span class="hljs-built_in">push</span>(start);<br>    <br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>()){<br>        <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <br>        <span class="hljs-keyword">int</span> distance = d[t];<br>        <span class="hljs-keyword">if</span>(t == end) <span class="hljs-keyword">return</span> d[t];<br>        <br>        <span class="hljs-comment">//状态转移,把1维数组2维化</span><br>        <span class="hljs-keyword">int</span> k = t.<span class="hljs-built_in">find</span>(<span class="hljs-string">'x'</span>);<br>        <span class="hljs-keyword">int</span> x = k/<span class="hljs-number">3</span>, y = k % <span class="hljs-number">3</span>;<br>        <br>        <span class="hljs-keyword">int</span> dx[<span class="hljs-number">4</span>] = {<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>}, dy[<span class="hljs-number">4</span>] = {<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>};<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++){<br>            <span class="hljs-keyword">int</span> a = x + dx[i], b = y + dy[i];<br>            <span class="hljs-keyword">if</span>(a &gt;= <span class="hljs-number">0</span> &amp;&amp; a &lt; <span class="hljs-number">3</span> &amp;&amp; b &gt;= <span class="hljs-number">0</span> &amp;&amp; b &lt; <span class="hljs-number">3</span>){<br>                <span class="hljs-keyword">int</span> temp = a * <span class="hljs-number">3</span> + b;<br>                <span class="hljs-built_in">swap</span>(t[k], t[temp]);    <br>                <span class="hljs-keyword">if</span>(!d.<span class="hljs-built_in">count</span>(t)){<br>                    q.<span class="hljs-built_in">push</span>(t);<br>                    d[t] = distance + <span class="hljs-number">1</span>;<br>                }<br>                <span class="hljs-built_in">swap</span>(t[k], t[temp]);<br>            }<br>            <br>        }<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>}<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>{<br>    <br>    <span class="hljs-keyword">char</span> c;<br>    string start;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++){<br>        cin &gt;&gt; c;<br>        start += c;<br>    }<br>        <br>    cout &lt;&lt; <span class="hljs-built_in">bfs</span>(start) &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">zxr</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://xurui314.github.io/2021/11/27/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/">https://xurui314.github.io/2021/11/27/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/">算法题目</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/10/19/qF6yCf8W2B5GeNx.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer=""></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/11/28/Dp%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"><img class="prev-cover" src="https://i.loli.net/2021/11/30/bKs7DOh8kwvZSrJ.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">Dp问题汇总</div></div></a></div><div class="next-post pull-right"><a href="/2021/11/23/new-journey/"><img class="next-cover" src="https://i.loli.net/2021/10/19/DuaemVZIMi3YBoS.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">new journey</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2021/08/26/算法题目练习/" title="AcWing-Oj-刷题学习记录(基础算法)"><img class="cover" src="https://i.loli.net/2021/08/25/bPy5m3j9QAilwr2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-26</div><div class="title">AcWing-Oj-刷题学习记录(基础算法)</div></div></a></div><div><a href="/2021/11/30/Divide-and-Conquer/" title="Divide and Conquer"><img class="cover" src="https://i.loli.net/2021/11/30/n8t3yAfYpEKDoXc.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-30</div><div class="title">Divide and Conquer</div></div></a></div><div><a href="/2021/11/28/Dp问题汇总/" title="Dp问题汇总"><img class="cover" src="https://i.loli.net/2021/11/30/bKs7DOh8kwvZSrJ.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-28</div><div class="title">Dp问题汇总</div></div></a></div><div><a href="/2021/07/26/FFT/" title="FFT的详解"><img class="cover" src="https://i.loli.net/2021/07/27/6fy8mTCbAOWPkrq.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-26</div><div class="title">FFT的详解</div></div></a></div><div><a href="/2021/12/01/算法课程总结/" title="算法课程总结"><img class="cover" src="https://i.loli.net/2021/08/14/H4dzFVGr61uEo3Y.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-01</div><div class="title">算法课程总结</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s2.loli.net/2021/12/08/yTYthVwXD4IPbJ9.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="author-info__name">zxr</div><div class="author-info__description">Think and Do like an MIT student</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">41</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">21</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">10</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/XuRui314"><i class="fab fa-github"></i><span>This is zxr!🚀</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/XuRui314" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://mail.qq.com/" target="_blank" title="Email-1977289398@qq.com"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">zxr的生活，math，编程记录,<div class="twopeople"><div class="container" style="height:200px;"><canvas class="illo" width="800" height="800" style="max-width: 200px; max-height: 200px; touch-action: none; width: 640px; height: 640px;"></canvas></div><script src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/js/twopeople1.js"></script><script src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/js/zdog.dist.js"></script><script id="rendered-js" src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/js/twopeople.js"></script><style>.twopeople{margin: 0;align-items: center;justify-content: center;text-align: center;}canvas{display: block;margin: 0 auto;cursor: move;}</style></div><div class="twopeople"></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%BE%E8%AE%BA"><span class="toc-number">1.</span> <span class="toc-text"> 图论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.1.</span> <span class="toc-text"> 模板</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-number">1.1.0.1.</span> <span class="toc-text"> 图的存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E8%8A%82%E7%82%B9%E6%89%80%E8%BF%9E%E7%9A%84%E8%BE%B9"><span class="toc-number">1.1.0.2.</span> <span class="toc-text"> 遍历节点所连的边</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84dfs%E9%81%8D%E5%8E%86"><span class="toc-number">1.1.0.3.</span> <span class="toc-text"> 图的DFS遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84bfs%E9%81%8D%E5%8E%86"><span class="toc-number">1.1.0.4.</span> <span class="toc-text"> 图的BFS遍历</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dfs"><span class="toc-number">1.2.</span> <span class="toc-text"> DFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bfs"><span class="toc-number">1.3.</span> <span class="toc-text"> BFS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF"><span class="toc-number">1.4.</span> <span class="toc-text"> 最短路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E4%BD%93%E6%84%9F%E7%9F%A5%E7%90%86%E8%A7%A3"><span class="toc-number">1.4.0.1.</span> <span class="toc-text"> 总体感知理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%B4%E7%B4%A0dijkstra"><span class="toc-number">1.4.0.2.</span> <span class="toc-text"> 朴素Dijkstra</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF-2"><span class="toc-number">1.4.0.2.1.</span> <span class="toc-text"> 模板</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98"><span class="toc-number">1.4.0.2.2.</span> <span class="toc-text"> 习题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E4%BC%98%E5%8C%96%E7%9A%84dijkstra"><span class="toc-number">1.4.0.3.</span> <span class="toc-text"> 堆优化的Dijkstra</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF-3"><span class="toc-number">1.4.0.3.1.</span> <span class="toc-text"> 模板</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98-2"><span class="toc-number">1.4.0.3.2.</span> <span class="toc-text"> 习题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bellman-ford"><span class="toc-number">1.4.0.4.</span> <span class="toc-text"> Bellman-Ford</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF-4"><span class="toc-number">1.4.0.4.1.</span> <span class="toc-text"> 模板</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98-3"><span class="toc-number">1.4.0.4.2.</span> <span class="toc-text"> 习题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#spfa"><span class="toc-number">1.4.0.5.</span> <span class="toc-text"> Spfa</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF-5"><span class="toc-number">1.4.0.5.1.</span> <span class="toc-text"> 模板</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98-4"><span class="toc-number">1.4.0.5.2.</span> <span class="toc-text"> 习题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#floyd"><span class="toc-number">1.4.0.6.</span> <span class="toc-text"> Floyd</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF-6"><span class="toc-number">1.4.0.6.1.</span> <span class="toc-text"> 模板</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98-5"><span class="toc-number">1.4.0.6.2.</span> <span class="toc-text"> 习题</span></a></li></ol></li></ol></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">1.5.</span> <span class="toc-text"> 最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%B4%E7%B4%A0prim"><span class="toc-number">1.5.0.1.</span> <span class="toc-text"> 朴素Prim</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF-7"><span class="toc-number">1.5.0.1.1.</span> <span class="toc-text"> 模板</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98-6"><span class="toc-number">1.5.0.1.2.</span> <span class="toc-text"> 习题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#kruskal"><span class="toc-number">1.5.0.2.</span> <span class="toc-text"> Kruskal</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF-8"><span class="toc-number">1.5.0.2.1.</span> <span class="toc-text"> 模板</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98-7"><span class="toc-number">1.5.0.2.2.</span> <span class="toc-text"> 习题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E5%9B%BE"><span class="toc-number">1.6.</span> <span class="toc-text"> 二分图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9F%93%E8%89%B2"><span class="toc-number">1.6.0.1.</span> <span class="toc-text"> 二分图染色</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95"><span class="toc-number">1.6.0.2.</span> <span class="toc-text"> 匈牙利算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E6%B5%81"><span class="toc-number">1.7.</span> <span class="toc-text"> 最大流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ford-fullkerson"><span class="toc-number">1.7.0.1.</span> <span class="toc-text"> Ford-Fullkerson</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF-9"><span class="toc-number">1.7.0.1.1.</span> <span class="toc-text"> 模板</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98-8"><span class="toc-number">1.7.0.1.2.</span> <span class="toc-text"> 习题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2"><span class="toc-number">2.</span> <span class="toc-text"> 搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E6%BC%AB%E8%B0%88"><span class="toc-number">2.1.</span> <span class="toc-text"> 搜索漫谈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">2.2.</span> <span class="toc-text"> 搜索的优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E4%B9%A0%E9%A2%98"><span class="toc-number">2.3.</span> <span class="toc-text"> 搜索习题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%88%86%E6%90%9Cdfs"><span class="toc-number">2.3.0.1.</span> <span class="toc-text"> 爆搜DFS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%B7%E5%AE%AB%E5%9E%8B-bfs"><span class="toc-number">2.3.0.2.</span> <span class="toc-text"> 迷宫型 BFS</span></a></li></ol></li></ol></li></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/01/14/Machine-Learning-Coding/" title="Machine Learning Code"><img src="https://s2.loli.net/2022/01/14/LaGcAPJX9QpgTBH.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Machine Learning Code"></a><div class="content"><a class="title" href="/2022/01/14/Machine-Learning-Coding/" title="Machine Learning Code">Machine Learning Code</a><time datetime="2022-01-14T12:42:54.000Z" title="Created 2022-01-14 20:42:54">2022-01-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/12/Attack-on-Titan/" title="zxr青春的补完---Attack on Titan"><img src="https://s2.loli.net/2022/01/12/qWYLfoIhz4vakJU.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="zxr青春的补完---Attack on Titan"></a><div class="content"><a class="title" href="/2022/01/12/Attack-on-Titan/" title="zxr青春的补完---Attack on Titan">zxr青春的补完---Attack on Titan</a><time datetime="2022-01-12T14:37:42.000Z" title="Created 2022-01-12 22:37:42">2022-01-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/10/Asuka/" title="Asuka"><img src="https://s2.loli.net/2022/01/10/naGjKA2SuoWtZkc.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Asuka"></a><div class="content"><a class="title" href="/2022/01/10/Asuka/" title="Asuka">Asuka</a><time datetime="2022-01-10T11:42:45.000Z" title="Created 2022-01-10 19:42:45">2022-01-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/09/%E8%87%AA%E6%88%91%E5%8F%8D%E7%9C%81/" title="Self-criticism"><img src="https://s2.loli.net/2022/01/09/7uczh3dySMCm1Y5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Self-criticism"></a><div class="content"><a class="title" href="/2022/01/09/%E8%87%AA%E6%88%91%E5%8F%8D%E7%9C%81/" title="Self-criticism">Self-criticism</a><time datetime="2022-01-09T15:41:25.000Z" title="Created 2022-01-09 23:41:25">2022-01-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/06/java-learning/" title="java learning"><img src="https://s2.loli.net/2022/01/06/xacLs9uH5RWeUME.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="java learning"></a><div class="content"><a class="title" href="/2022/01/06/java-learning/" title="java learning">java learning</a><time datetime="2022-01-06T11:16:33.000Z" title="Created 2022-01-06 19:16:33">2022-01-06</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">©2020 - 2022 By zxr</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="github-badge"><a style="color: #fff" rel="license" href="https://hexo.io/" target="_blank" title="由 Hexo 强力驱动"><span class="badge-subject">Powered</span><span class="badge-value bg-blue">Hexo</span></a><a style="color: #fff" rel="license" href="https://gitee.com/" target="_blank" title="静态网页托管于 GitHub Pages 和 Coding Pages 和 Gitee Pages"><span class="badge-subject">Hosted</span><span class="badge-value bg-brightgreen">GitHub &amp; Coding &amp; Gitee</span></a><a style="color: #fff" rel="license" href="https://www.jsdelivr.com/" target="_blank" title="jsDelivr 提供 CDN 加速服务"><span class="badge-subject">CDN</span><span class="badge-value bg-orange">jsDelivr</span></a><a style="color: #fff" rel="license" href="https://jerryc.me" target="_blank" title="站点使用 Butterfly主题"><span class="badge-subject">Theme</span><span class="badge-value bg-blue">Butterfly</span></a><a style="color: #fff" rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" title="本站点采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可"><span class="badge-subject"><i class="fa fa-copyright"></i></span><span class="badge-value bg-lightgrey">BY-NC-SA 4.0  </span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="Increase font size"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="Decrease font size"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = '[object Object]'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'https://xurui314.github.io/2021/11/27/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/'
    this.page.identifier = '2021/11/27/搜索与图论/'
    this.page.title = '搜索与图论'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }
}

if ('Valine' === 'Disqus' || !false) {
  if (false) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><script src="https://cdn.jsdelivr.net/gh/XuRui314/live2d-widget@1.0.1/autoload.js"></script><script src="/js/title.js"></script><script src="/dist/nochocolate.js"></script><div id="aplayer"></div><script type="text/javascript" src="/dist/APlayer.min.js"></script><script type="text/javascript" src="/dist/music.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.removeEventListener('scroll', window.tocScrollFn)
  window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --> <script data-pjax="">if(document.getElementById('recent-posts') && (location.pathname ==='all'|| 'all' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="https://XuRui314.github.io/categories/Math/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📚 zxrの数学世界 (10)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://XuRui314.github.io/categories/算法学习/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🎮 zxrの算法学习 (5)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://XuRui314.github.io/categories/生活趣闻/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🐱‍👓 zxrの生活趣闻 (4)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://XuRui314.github.io/categories/编程实例/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">👩‍💻 zxrの编程学习 (5)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://XuRui314.github.io/categories/生活感悟/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🚴‍♂ zxrの生活感悟 (9)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://XuRui314.github.io/categories/Hexo/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">💌 zxrのBlog记录 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><a class="magnet_link_more"  href="https://XuRui314.github.io/categories" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(50% - 5px);background: #f2f2f2;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: #b30070}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style> <script data-pjax="">if(document.getElementById('recent-posts') && location.pathname =='/'){
    
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src="https://i.loli.net/2021/09/17/9H5WSbTrVejOdkz.jpg" alt="https://i.loli.net/2021/09/17/9H5WSbTrVejOdkz.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2021-09-17</span><a class="blog-slider__title" href="2021/09/17/概率和测度/">概率和测度(ZJU大佬)</a><div class="blog-slider__text">来看看ZJU计科大佬解释概率和测度🥙</div><a class="blog-slider__button" href="2021/09/17/概率和测度/">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src="https://i.loli.net/2021/08/25/bPy5m3j9QAilwr2.jpg" alt="https://i.loli.net/2021/08/25/bPy5m3j9QAilwr2.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2021-08-26</span><a class="blog-slider__title" href="2021/08/26/算法题目练习/">AcWing-Oj-刷题学习记录(基础算法)</a><div class="blog-slider__text">来看算法蒟蒻的丢人日常啊👩‍🦽</div><a class="blog-slider__button" href="2021/08/26/算法题目练习/">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src="https://i.loli.net/2021/08/15/NYcSXrECnvzOiLP.jpg" alt="https://i.loli.net/2021/08/15/NYcSXrECnvzOiLP.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2021-08-15</span><a class="blog-slider__title" href="2021/08/15/两层神经网络识别手写数字/">两层神经网络识别手写数字</a><div class="blog-slider__text">识别手写数字最简单的实现🧦</div><a class="blog-slider__button" href="2021/08/15/两层神经网络识别手写数字/">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src="https://i.loli.net/2021/08/15/F8aP7R36IidpCt5.jpg" alt="https://i.loli.net/2021/08/15/F8aP7R36IidpCt5.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2021-08-14</span><a class="blog-slider__title" href="2021/08/14/神经网络搭建准备内容/">神经网络搭建准备内容</a><div class="blog-slider__text">如何识别手写🔢，zxr带你一步一步实现🎼</div><a class="blog-slider__button" href="2021/08/14/神经网络搭建准备内容/">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src="https://i.loli.net/2021/08/12/SJs3MgYC7x8IU26.jpg" alt="https://i.loli.net/2021/08/12/SJs3MgYC7x8IU26.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2021-08-12</span><a class="blog-slider__title" href="2021/08/12/xuperchain-solidity/">xuperchain&solidity</a><div class="blog-slider__text">区块链不止是挖币，还有v神和solidity🎈</div><a class="blog-slider__button" href="2021/08/12/xuperchain-solidity/">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src="https://i.loli.net/2021/07/27/6fy8mTCbAOWPkrq.png" alt="https://i.loli.net/2021/07/27/6fy8mTCbAOWPkrq.png"/></div><div class="blog-slider__content"><span class="blog-slider__code">2021-07-26</span><a class="blog-slider__title" href="2021/07/26/FFT/">FFT的详解</a><div class="blog-slider__text">这么好看的FFT，信号狗都馋哭了💦</div><a class="blog-slider__button" href="2021/07/26/FFT/">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src="https://i.loli.net/2021/08/09/zdt4YKoehQvR96S.jpg" alt="https://i.loli.net/2021/08/09/zdt4YKoehQvR96S.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2021-08-09</span><a class="blog-slider__title" href="2021/08/09/炒鸡好理解的测度论/">炒鸡好理解的测度论</a><div class="blog-slider__text">三段字，让你读懂测度论</div><a class="blog-slider__button" href="2021/08/09/炒鸡好理解的测度论/">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src="https://i.loli.net/2021/08/12/wF7TJlqxOLEWGQk.png" alt="https://i.loli.net/2021/08/12/wF7TJlqxOLEWGQk.png"/></div><div class="blog-slider__content"><span class="blog-slider__code">2021-07-27</span><a class="blog-slider__title" href="2021/07/27/FT/">傅里叶学习资料</a><div class="blog-slider__text">简单好学的傅里叶学习资料</div><a class="blog-slider__button" href="2021/07/27/FT/">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src="https://i.loli.net/2021/07/27/f7jO8hlNpzWVXSP.jpg" alt="https://i.loli.net/2021/07/27/f7jO8hlNpzWVXSP.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2021-07-26</span><a class="blog-slider__title" href="2021/07/26/hello-world/">大鸟转转转酒吧内部绝密档案</a><div class="blog-slider__text">不要点进来QAQ！</div><a class="blog-slider__button" href="2021/07/26/hello-world/">详情</a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载swiper')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script>
<script data-pjax="" src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper/swiper/swiper.min.js"></script>
<script data-pjax="" src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper@0.18/swiper/swiperindex.js"></script>
<style></style><script data-pjax="">function electric_clock_injector_config(){
                var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
                var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img id="card-clock-loading" src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-clock/clock/images/weather/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading" class="entered loading"></div></div></div></div></div>';
                console.log('已挂载electric_clock')
                // parent_div_git.innerHTML=item_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",item_html) // 有报错，但不影响使用(支持pjax跳转)
            }if( document.getElementsByClassName('sticky_layout')[0] && (location.pathname ==='all'|| 'all' ==='all')){

            electric_clock_injector_config()
        } </script><script src="https://pv.sohu.com/cityjson?ie=utf-8"></script><script data-pjax="" src="https://cdn.jsdelivr.net/gh/Zfour/hexo-electric-clock@1.0.6/clock.js"></script>
  <script data-pjax="" src="https://cdn.jsdelivr.net/gh/Zfour/hexo-github-calendar@1.21/hexo_githubcalendar.js"></script>
  <script data-pjax="">
        function GithubCalendarConfig(){
            var git_githubapiurl ="https://python-github-calendar-api.vercel.app/api?XuRui314";
            var git_color =['#ebedf0', '#fdcdec', '#fc9bd9', '#fa6ac5', '#f838b2', '#f5089f', '#c4067e', '#92055e', '#540336', '#48022f', '#30021f'];
            var git_user ="XuRui314";
            var parent_div_git = document.getElementById('recent-posts');
            var git_div_html = '<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><div id="github_loading" style="height:100%;display: flex;align-items: center;justify-content: center;"><svg style="height:50px" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"  viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animateTransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animateTransform></path></svg></div><div id="github_container"></div></div>';
            if(parent_div_git && location.pathname =='/'){
                console.log('已挂载github calendar')
                // parent_div_git.innerHTML=git_div_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",git_div_html) // 有报错，但不影响使用(支持pjax跳转)
            };
            GithubCalendar(git_githubapiurl,git_color,git_user)
        }
        if(document.getElementById('recent-posts')){
            GithubCalendarConfig()
        }
    </script>
    <style>#github_container{min-height:248px}@media screen and (max-width:650px) {#github_container{background-image:;min-height:0px}}</style>
    <style></style><script async="" src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"live2d-widget-model-wanko"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7},"log":false});</script></body></html>